---
title: Software Design
---

# Portable Laser Engravers Interface Design

### Overview
<!-- This can be taken from the requirements and modified as necessary. For a design document you can assume the reader has a technical background. For your projects assume a background of a class member. -->

The [HTPOW brand](https://www.amazon.com/HTPOW-Engraver-Printer-Handicraft-Engraving/dp/B01G36Q558) of laser engravers have a (somewhat) unique protocol for communicating between the computer and the engraver. There is software available for using the engravers, but it only runs on Windows and is not compatible with [Wine](https://www.winehq.org/). Our goal is to examine and replicate the features of this Windows software in a command-line interface so that engraving can be better automated and will work nicely in Linux, Windows, and Mac environments.

### Environment

<!-- List any requirements (operating system, database products, execution environment (Java, Perl, etc.). -->

Our engraving software is written in C++ <!-- TODO --> and needs a gcc compiler. It has been tested in Ubuntu 14.04 and 16.04, gcc version 5.2.1. Although not guaranteed, this code should be able to compile on any Linux/Unix system with a gcc compiler, possibly including Mac OS X.

This software depends on the following libraries, which are linked or available through the GNU Standard Library: <!-- TODO -->

### Module Descriptions and Data Flow

<!--Include a diagram showing the modules and data flow between them. Give a high level description of the function of each module. A pseudo-code format is often used:

```
Open grades file
While grades for student in file {
  If valid grade (0-100)
    Add grade to student total
  else  {
    Report error to user screen
    Create error report for history
  } 
}
```

Describe the data going into and out of the modules, using structures as necessary. -->

<!-- TODO a module diagram might be nice -->

Overall the program accepts 2 kinds of data, pictures to carve and user command line input to interpret. The CLI Parser module, short for Command Line Input Parser, handles parsing the user's input so the program can interpret the commands the user wants to execute. The CLI Parser takes in user input and from it determines what options to set for the image and what image to carve. The Resize Image module resizes the input image to the size that the engraver can print. Then the Convert to Greyscale module converts the image to greyscale so that color images can be engraved. The last image manipulation module is the Threshold module which converts the greyscale pixels to black and white pixels only, based on the threshold value the user entered. If no threshold value was entered then the engraver engraves the greyscale image. The Streamer module is what brings it all together and determines how to break down the image and options into the correct protocol to send to the engraver. <!-- I don't know what the Protocol Definitions module is for so add that here. --> 

```
	Interpret CLI options
	Read in bitmap file
	<< Enhancement: Analyze bitmap for contiguous regions >>
	Test connection to serial port
	Activate engraver
	while( there are regions to engrave ) do
		while( there are pixels to engrave in this region ) do
			<< Enhancement: Greyscale settings: Set laser intensity >>
			Move laser to next pixel
		end
		Travel to next region
		Alert user, bitmap complete
	end
```

<!-- TODO #### G-code (.mpt) Format
```
``` -->

### User Screens

<!-- Include user screens with description of function and use. -->
```
htpewpew: a CLI for serial communication to a HTPOW laser engraver
usage: htpewpew image [options] 
  -b, --max-burn-time t     Set the maximum burn time (default = ? ms)
  -d, --dry-run             Show engraving box and do not engrave
  -i, --max-intensity s     Set the maximum burn intensity (default = ?)
  -o, --output image        Store the altered image at this location
  -p, --port port-num       Send the file to this serial port.
  -t, --bw, --threshold x%  Use a threshold with x% (default = 50%)
  -x, --x-offset x          Set x offset for image
  -y, --y-offset y          Set y offset for image
  -h, --help                Display this help message and quit.
```

<!-- Maybe add a screenshot even if it is just a terminal. -->

### User Scenarios (Use Cases)

<!-- Include the typical steps a user would do for major functions:

1.    When the user starts the program the first screen appears shown above as “Main Menu” appears
2.    When the user selects option “Enter grades” the “Enter Grades” screen appears
3.    The user can enter grades by …. When finished the user …. 
4.    The report shown above as “Grade Report” is generated by …… -->

A user will start the program from the command line, entering any options they want to change as the program is called. In most cases the user will start by calling the program with the -d option to see the cutting area of the laser on the media they wish to cut. Then the user can adjust the location of the cutting area with the -x and -y options. Once the laser is in the correct location on the media the user would then call the program with any of the cutting settings (-b, -i) or image settings (-t) they want to change from default values and the engraving will begin automatically.

<!-- I may misunderstand how we intend to do this program but based on what it looks like right now I think we should change it. I feel like we should call the program with a serial port passed to it and then the program sits and waits for user input until it gets an image and the go to start engraving. Once the engraving has begun the user can't send anymore commands. Once its done the program spits out a completion status and goes back to waiting for an image to cut and accept changes to settings. -->

### Design Considerations

<!-- List any considerations that affected your design, for example functions you considered but cannot do because of time or system limitations, design decisions made because of customer requirements, etc. -->

The most important requirement was that the program work in Linux. This affected our design decision to code in C++ since it works well in Linux and will be more portable across all its distributions. C++ is also the language we as a team have the most experience programming in, which further affected our decision to write the program in C++. 

We chose not to make a graphical user interface for the program. One reason we made this decision was because none of us have any experience in making GUIs, so we would have to put a lot of time into making one which could spent adding more features instead. Also our customer is very familiar with terminal based programs and not having a GUI in favor of more options in the program is an acceptable trade. 

We have also considered adding more functionality than what the current Super Carver program does. Currently the engraver starts at the top left of the image and engraves left to right moving down. There is no real optimization of the cutting path. Depending on how much time remains after we deliver all of the base functionalities we may looking at adding options to optimize the cutting path. The important thing to note is that there is unlikely to be a one size fits all algorithm for optimization, so the idea would be to offer a few different options for optimization and the user can experiment to see what works best for their image.

### Sizing Estimate

<!-- Size estimates of modules, either lines of code, story points, or function points (see the Software Process and Project metrics slides). Note: Its accuracy will not affect your grade -->

Based on the modules in the above data flow diagram we estimated how many lines of code each module will require, and based on our schedule we estimated the number of student weeks we have to complete the project.

<!-- Basically I would like to put our sizing extimates slide in here from the presentation but I am not sure how to do that in a markdown file. -->

Size in Lines of Code

150 Command Line Parser

100 Protocol Definitions

300 Image Preparation
* 100 Resize
* 100 Greyscale
* 100 Threshold for Monochrome

500 Streamer
<hr/>
1050 Total Lines of Code

### Documentation specific to your project

<!-- This is an outline of a generic project. Modify it to suite yours. The design document is used by the project members to complete the project and for technically competent readers to understand what you are doing. -->

<!-- I don't think this is meant to be a separate heading. I think this was in the online specification to indicate that we can add other sections to the design report that make sense. I feel like we could maybe add our schedule or leave it out and not even mention it in sizing. I can't think of any extra sections we should really have except maybe something specifically about the engraver in general, but since that is taken care of elsewhere on the site it kind of seems redundant. Let me know what you think. -->

### The Formal Development Environment (for reference)

<!-- In a formal project development environment, the design document is approved by the project manager and technical leaders responsible for development.

The design document can be changed if necessary during product development. However there usually is a procedure to do this (with appropriate approvals needed). When a design change is being considered, affected groups have to be notified and may have to approve. For example, if a design change affects the requirements approved by the customer, customer approval is necessary.

It is also recommended that testing groups participate and approve the design. Testing groups like the integration and system groups use the design document to create test cases.

For your projects, the customer does not have to approve the design document. However, anything in it that affects the customer (platform, user screens, etc.) must be approved. -->

<!-- This is another section that I don't think is meant to be a section in the report. I think this is just him explaining how a design document is more likely to go in the real world. -->
