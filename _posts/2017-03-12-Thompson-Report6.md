---
layout: post
tags: thompson
title: Week 6 Report
---

### Mar. 12, 2017

After studying and comparing several of our data captures of different images I believe I have finally figured out the remaining question about the protocol the control program uses with the engraver. First it sends the usual 5 set up commands then waits for a response from the engraver. After it gets a response it starts sending the image data with the starting number dependant on which response the engraver sent. If the engraver sent 3e:01:ff:ff the numbering starts at 5b. If it sent 3e:02:ff:ff the numbering starts from 3d. After waiting for this first response so it knows where to begin numbering, the software then sends 90 7 byte instructions and waits on a response from the engraver. The engraver will usually respond twice in the middle of the 90 command sending, but the software ignores them. After the initial 90 commands the software waits for a response from the engraver and then sends 30 more commands and waits for a response. From here on the software continously sends 30 commands and waits for a response until done. Until we captured a larger image this pattern could not be seen because the smaller images only took around 130 or so commands to complete.

### Mar. 31, 2017
New information has shown that what I thought before about the software sending 90 commands and then waiting is incorrect. The software does a read every 30 instructions to wait and make sure it is not overloading the engraver. Our data captures show the engraver sending a message to the software while the software is still sending instructions during the first 90 instructions. This made it appear as though the software was not looking for messages from the engraver for the first 90 instructions. Some of the data captures, however, showed the software waiting on the engraver after 60 instructions. 

When you look more closely at the timings of the messages you can see that the software was sending messages faster in the captures where it waited after 60 instructions. The message that the engraver sends to the software is a message letting the software know that it is ready for more data, or that its buffer is empty. If the software is sending messages too slowly, or the engraver is able to empty its buffer too quickly then it will send the signal before the software has a chance to wait for the signal. Then when the software reads to look for the signal after 30 instructions, the signal is already in the read buffer and the software doesn't have to wait for it. This makes it look like the software doesn't wait for the message, when in reality it does. This can be seen easiest by comparing the times between the 30 instructions. In the data captures where the software obviously waits after 60 instructions, the time to send those 60 instructions was much less than the time to send the first 60 instructions in the data captures where the software doesn't appear to wait until after 90 instructions. One data capture breaks this trend, the X shape, but when you take into account the shape it is clear that although the instructions weren't sent any faster the engraver couldn't process them as fast due to the extra travel time in the X shape so it couldn' clear its buffer quickly and the software had to wait for a message after 60 instructions.
